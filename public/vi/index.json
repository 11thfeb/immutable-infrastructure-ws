[
{
	"uri": "//localhost:1313/vi/",
	"title": "Packer Ansible Terraform for Immutable Infrastructure",
	"tags": [],
	"description": "",
	"content": "Packer/Ansible/Terraform for Immutable Infrastructure Tổng quan Trong workshop này, chúng ta sẽ khám phá những kiến thức cơ bản và bài tập thực hành về Packer, Ansible và Terraform cho Immutable Infrastructure. Những công cụ này là rất quan trọng để tự động hóa quá trình cung cấp và triển khai cơ sở hạ tầng của bạn. Bạn sẽ có cơ hội trải nghiệm thực tế bằng cách tạo kết nối cho cả các instance công cộng và riêng tư, giúp bạn tối ưu hóa quy trình phát triển hiệu quả. Hãy bắt đầu và khám phá khả năng của Packer, Ansible và Terraform cùng nhau.\nContent Giới thiệu Các bước chuẩn bị Tạo user, policy \u0026amp; access key Cấu hình AWS CLI Viết Ansible Playbook Viết Packer Viết Terraform Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.1-install-packer/",
	"title": "Cài đặt Packer",
	"tags": [],
	"description": "",
	"content": "2.1. Cài đặt Packer https://developer.hashicorp.com/packer/install?product_intent=packer\n$ wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg $ echo \u0026#34;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/hashicorp.list $ sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install packer Kiểm tra cài đặt Sau khi cài đặt Packer, hãy xác minh quá trình cài đặt đã hoạt động bằng cách mở dấu nhắc lệnh hoặc bảng điều khiển mới và kiểm tra xem trình đóng gói có sẵn không:\n$ packer --version Packer v1.10.3 "
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu",
	"tags": [],
	"description": "",
	"content": "Tại sao sử dụng Immutable Servers? Cộng đồng DevOps đã chấp nhận khái niệm Immutable Server với lý do chính đáng. Immutable servers được triển khai hoàn toàn bằng các công cụ tự động hóa, và một DevOps không cần phải truy cập vào máy chủ để tự cấu hình nó bằng cách thủ công. Điều này dẫn đến hệ thống dễ dự đoán được - cách mà một máy chủ được cấu hình có thể được dự đoán gần như chính xác bằng những gì có trong bản kiểm soát mã nguồn của bạn (Source Control). Immutable servers triển khai nhanh hơn, vì máy tính có thể thao tác nhanh hơn con người.\nChúng cũng có thể an toàn hơn. Khi máy chủ dự đoán và nhanh chóng triển khai lại, các sysadmin không cần có nhiều động cơ để chúng chạy trong thời gian dài. Nếu bạn thường xuyên triển khai lại các máy chủ hàng ngày (hoặc thậm chí hàng giờ, trong trường hợp của một số công ty triển khai nhiều lần trong một ngày), thì một kẻ xâm nhập nào đó có thể không có nhiều thời gian để thiết lập và khám phá. Các máy chủ chạy lâu là một rủi ro: việc xâm nhập vào Equifax đã xảy ra trong khoảng thời gian 76 ngày. Immutable servers với tuổi thọ ngắn là một phần quan trọng của một chiến lược phòng ngự chặt chẽ.\nCông cụ DevOps là gì? Có nhiều cách tiếp cận để tạo ra các máy chủ bất biến. Khi tham gia dự án hiện tại của mình tại công ty, tôi đã gặp phải một ngăn xếp mới được sử dụng để tạo các immutable servers trong GovCloud của Amazon Web Services (AWS). Khi đã quen với Terraform, trước đây tôi chưa từng sử dụng Packer hoặc Ansible. Bây giờ tôi đã dành phần lớn thời gian trong năm để làm việc với hệ thống này. Mặc dù việc thiết lập ngăn xếp hơi phức tạp (ít nhất là so với mô hình \u0026ldquo;bash script chạy trên các nút mới\u0026rdquo;) nhưng độ tin cậy, tốc độ triển khai nhanh và khả năng hiển thị mà ngăn xếp này mang lại khiến cho công sức thiết lập ban đầu trở nên xứng đáng.\nPacker https://www.packer.io\nPacker là sản phẩm của Hashicorp. Theo cách nói của họ, “Packer là một công cụ nguồn mở để tạo các images giống hệt nhau cho nhiều nền tảng từ một cấu hình nguồn duy nhất”. Tôi sử dụng Packer để lấy Hình ảnh máy Amazon (AMI) nhằm tạo ra các phiên bản mới của những AMI này có tất cả cấu hình và phần mềm mà chúng tôi cần để chạy ứng dụng của mình một cách an toàn trong AWS.\nPacker hỗ trợ nhiều “provisioners xử lý cấu hình máy chủ thực tế. Đây có thể là các tập lệnh shell đơn giản hoặc có thể là một công cụ mạnh mẽ hơn như Ansible. Packer xử lý việc tạo VM và đóng gói dưới dạng AMI, Ansible xử lý cấu hình của máy ảo.\nAnsible https://www.ansible.com\nAnsible được Red Hat tạo ra như một công cụ quản lý cấu hình. Nó tự động hóa tất cả cài đặt phần mềm, quản lý gói và cấu hình trên máy chủ AWS EC2 của chúng tôi. Ansible đảm bảo rằng mọi phần mềm, thay đổi tệp cấu hình hoặc công việc định kỳ đều được cài đặt theo cùng một cách.\nAnsible không có tác nhân, vì vậy chuỗi công cụ xây dựng của bạn có ít bộ phận chuyển động hơn. (Có lẽ phần tồi tệ nhất của DevOps là trở thành quản trị viên hệ thống cho các công cụ bạn xây dựng để thay thế bạn làm quản trị viên hệ thống.) Cú pháp YAML thật đáng kinh ngạc và được ghi chép đầy đủ. Hệ sinh thái Ansible Galaxy có rất nhiều sách hướng dẫn cho tất cả các loại nhiệm vụ quản lý máy chủ, từ việc triển khai máy chủ Apache tuân thủ các nguyên tắc bảo mật hệ thống.\nTerraform https://www.terraform.io/\nTerraform là một sản phẩm của Hashicorp. Nó cho phép chúng tôi “tạo, thay đổi và cải thiện cơ sở hạ tầng một cách an toàn và có thể dự đoán được”. Thuật ngữ cơ sở hạ tầng đề cập đến các thành phần như phiên bản EC2, bộ cân bằng tải, cơ sở dữ liệu và kết nối mạng. Terraform tích hợp với API AWS để dịch và chạy mã cấu hình thành các lệnh gọi API AWS nhằm cung cấp kiến ​​trúc của chúng tôi – mọi thứ từ kết nối mạng đến máy chủ ứng dụng và bộ chứa S3. Sau khi tạo AMI bằng Packer và Ansible, chúng tôi sẽ sử dụng Terraform để triển khai AMI đó dưới dạng phiên bản EC2 vào môi trường đám mây của mình.\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "\rGhi chú: Chúng ta cần bắt đầu và kích hoạt nginx bằng cách sử dụng systemctl start và enable để đảm bảo rằng nginx sẽ sẵn sàng xử lý tự động.\nTrong workshop này, chúng ta sẽ tạo một AMI bằng cách sử dụng Packer và thực hiện cấu hình bằng cách sử dụng Ansible trong quá trình tạo. Một trang web tĩnh sẽ được triển khai. Và cùng một mã Ansible được sử dụng để cung cấp trang web tĩnh bằng cách sử dụng Nginx trong suốt quá trình tạo này. Các thẻ sẽ được gán cho AMI trong quá trình này. Mục đích là để xác định AMI mới nhất có sẵn và sẵn sàng cho việc tạo instance EC2. ID của Subnet sẽ được thu thập để Packer builder có thể tạo AMI bằng ID của Subnet. Ở đây, chúng ta sẽ quản lý mã terraform của mình trong hai phần khác nhau: một phần để tạo VPC, subnet và thông tin mạng khác, phần còn lại để nhóm instance EC2 trong mạng của chúng ta bằng AMI được tạo bởi Packer trước đó.\nNội dung Cài đặt Packer Cài đặt Ansible Cài đặt AWS CLI Cài đặt Terraform "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-install-ansible/",
	"title": "Cài đặt Ansible",
	"tags": [],
	"description": "",
	"content": "2.2. Cài đặt Ansible https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html\n# Install Ansible repository. $ sudo apt-get update \u0026amp;\u0026amp; sudo apt-get upgrade -y $ sudo apt-get install -y software-properties-common $ sudo apt-add-repository -y ppa:ansible/ansible # Install Ansible. $ sudo apt-get update $ sudo apt-get install -y ansible Kiểm tra cài đặt Sau khi cài đặt Ansible, xác minh rằng cài đặt đã hoạt động bằng cách mở một cửa sổ lệnh hoặc console mới và kiểm tra xem ansible có sẵn không:\n$ ansible --version ansible [core 2.14.6] "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-install-aws-cli/",
	"title": "Cài đặt AWS CLI",
	"tags": [],
	"description": "",
	"content": "2.3. Install AWS CLI https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html\n$ sudo apt-get update $ sudo apt-get install python3-pip $ sudo pip install awscli Kiểm tra cài đặt Sau khi cài đặt AWS CLI, xác minh rằng cài đặt đã hoạt động bằng cách mở một cửa sổ lệnh hoặc console mới và kiểm tra xem AWS CLI có sẵn không:\n## Verify Installation $ aws --version "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.4-install-terraform/",
	"title": "Cài đặt Terraform",
	"tags": [],
	"description": "",
	"content": "2.4. Cài đặt Terraform https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli\nĐảm bảo hệ thống của bạn được cập nhật và bạn đã cài đặt các gói gnupg, software-properties-common, và curl. Bạn sẽ sử dụng các gói này để xác minh chữ ký GPG của HashiCorp và cài đặt kho lưu trữ gói Debian của HashiCorp.\n$ sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y gnupg software-properties-common Cài đặt khóa GPG của HashiCorp.\n$ wget -O- https://apt.releases.hashicorp.com/gpg | \\ gpg --dearmor | \\ sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg \u0026gt; /dev/null Xác minh GPG key.\ngpg --no-default-keyring \\ --keyring /usr/share/keyrings/hashicorp-archive-keyring.gpg \\ --fingerprint Lệnh gpg sẽ báo cáo dấu vân tay của khóa:\n/usr/share/keyrings/hashicorp-archive-keyring.gpg ------------------------------------------------- pub rsa4096 XXXX-XX-XX [SC] AAAA AAAA AAAA AAAA uid [ unknown] HashiCorp Security (HashiCorp Package Signing) \u0026lt;security+packaging@hashicorp.com\u0026gt; sub rsa4096 XXXX-XX-XX [E] Thêm kho lưu trữ chính thức của HashiCorp vào hệ thống của bạn. Lệnh lsb_release -cs sẽ tìm mã phân phối cho hệ thống hiện tại của bạn, chẳng hạn như buster, groovy, hoặc sid.\n$ echo \u0026#34;deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \\ https://apt.releases.hashicorp.com $(lsb_release -cs) main\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/hashicorp.list Tải về \u0026amp; Cài đặt Terraform.\n$ sudo apt update $ sudo apt-get install terraform Kiểm tra cài đặt Sau khi cài đặt Terraform, xác minh rằng cài đặt đã hoạt động bằng cách mở một cửa sổ lệnh hoặc console mới và kiểm tra xem Terraform có sẵn không:\n$ terraform -help Usage: terraform [-version] [-help] \u0026lt;command\u0026gt; [args] The available commands for execution are listed below. The most common, useful commands are shown first, followed by less common or more advanced commands. If you\u0026#39;re just getting started with Terraform, stick with the common commands. For the other commands, please read the help and docs before usage. #... "
},
{
	"uri": "//localhost:1313/vi/3-create-user-policy/",
	"title": "Tạo user, policy &amp; access key.",
	"tags": [],
	"description": "",
	"content": "Trong bước này, chúng ta sẽ cần tạo 1 user test cho bài lab này.\nTạo user, policy \u0026amp; access key. Đi tới IAM service management console, nhấp vào nút “Create user” để tạo người dùng của bạn. Nhập tên người dùng của bạn và nhấp vào nút “Next” để chuyển sang bước tiếp theo. Chọn “Attach policies directly”, sau đó bạn có thể tìm kiếm trong thanh tìm kiếm “AdministratorAccess” và “EC2FullAccess”, chọn và nhấp vào nút “Next” để chuyển sang bước tiếp theo. Bạn có thể xem cấu hình cho tài khoản của mình, nhấp vào nút “Create user” để tạo người dùng của bạn. Đi tới Access Management console Chọn “Create access key” để tạo khóa truy cập của bạn. Chọn “Command Line Interface (CLI)”. Chọn “I understand the above recommendation and want to proceed to create an access key” checkbox và click vào “Next” để chuyển sang bước tiếp theo. Nhập tên khóa truy cập của bạn và nhấp vào nút “Create access key” để tạo khóa truy cập của bạn. Bạn có thể thấy khóa truy cập và khóa bí mật của mình trên màn hình. Bạn nên lưu lại access key và secret key của mình cho bước tiếp theo. "
},
{
	"uri": "//localhost:1313/vi/4-configure-aws-cli/",
	"title": "Cấu hình AWS CLI",
	"tags": [],
	"description": "",
	"content": "Ở bước trước, bạn đã tạo một tài khoản và nhận được access key \u0026amp; secret key. Ở bước này, bạn cần sử dụng access key \u0026amp; secret key để định cấu hình AWS CLI.\nKích hoạt CLI của bạn và nhập lệnh sau:\n$ aws configure AWS Access Key ID [********************]: AWS Secret Access Key [********************]: Default region name [us-east-1]: Default output format [None]: Bạn sẽ được nhắc nhập ID access key AWS, secret key AWS, default region và default output format.\nSau khi định cấu hình thành công AWS CLI, bạn có thể bắt đầu sử dụng nó để quản lý các dịch vụ AWS của mình.\nCác lệnh thường được sử dụng trong AWS CLI. Mô tả một phiên bản ec2. aws ec2 describe-instances List IAM User. aws iam list-users "
},
{
	"uri": "//localhost:1313/vi/5-ansible/",
	"title": "Viết Ansible Playbook",
	"tags": [],
	"description": "",
	"content": "Đầu tiên chúng ta tạo cấu trúc thư mục Ansible như dưới.\n$ tree . ├── ansible │ ├── ansible-playbook-wordpress-nginx │ │ ├── README.md │ │ ├── group_vars │ │ │ └── all │ │ ├── hosts │ │ ├── playbook.retry │ │ ├── playbook.yml │ │ └── roles │ │ ├── nginx │ │ │ ├── handlers │ │ │ │ └── main.yml │ │ │ ├── tasks │ │ │ │ └── main.yml │ │ │ └── templates │ │ │ ├── default-site.conf │ │ │ └── nginx-wp-common.conf │ │ ├── php │ │ │ ├── handlers │ │ │ │ └── main.yml │ │ │ └── tasks │ │ │ └── main.yml │ │ └── wordpress │ │ ├── README.md │ │ ├── handlers │ │ │ └── main.yml │ │ ├── tasks │ │ │ └── main.yml │ │ └── templates │ │ └── wp-config.php Trong group_vars/all, nhập nội dung sau:\n## group_vars/all # WordPress database settings wp_db_name: wordpress wp_db_user: wordpress wp_db_password: wordpress_db_password mysql_port: 3306 mysql_root_password: root auto_up_disable: true server_hostname: 11thfeb # WordPress Version wp_version: 4.7.5 wp_sha1sum: fbe0ee1d9010265be200fe50b86f341587187302 #Define Core Update Level #true = Development, minor, and major updates are all enabled #false = Development, minor, and major updates are all disabled #minor = Minor updates are enabled, development, and major updates are disabled core_update_level: true Trong host, nhập nội dung sau:\n[webservers] localhost Trong playbook.retry, nhập nội dung sau:\nlocalhost Trong playbook.yml, nhập nội dung sau:\n- hosts: localhost roles: - nginx - wordpress - php Ansible Roles cung cấp một cách có cấu trúc để sắp xếp các tác vụ, mẫu, tệp và biến. Cấu trúc này giúp quản lý các thiết lập tự động hóa phức tạp dễ dàng hơn vì mọi thứ liên quan đến một vai trò cụ thể đều được chứa trong thư mục của nó\nTrong thư mục role/nginx, hãy bắt đầu ghi cấu hình cho task và handlers.\nTạo một file main.yml trong roles/nginx/handlers:\n--- - name: restart nginx service: name=nginx state=restarted become: yes Tạo một file main.yml trong roles/nginx/tasks:\n--- # tasks file for nginx - name: Update apt cache apt: update_cache=yes cache_valid_time=3600 become: yes - name: Install nginx apt: name={{ item }} state=present become: yes with_items: - nginx - git - name: Start nginx become: yes service: name: nginx state: started - name: Update nginx confs for WordPress + PHP template: \u0026#34;src=../templates/default-site.conf dest=/etc/nginx/sites-available/default owner=www-data group=www-data mode=0644\u0026#34; become: yes - name: Enable site file: src=/etc/nginx/sites-available/default dest=/etc/nginx/sites-enabled/default owner=www-data group=www-data state=link notify: - restart nginx become: yes Bạn cần tạo 2 file cấu hình trong roles/nginx/templates\ndefault-site.conf server { listen 80 default_server; listen [::]:80 default_server; root /var/www/11thfeb; # Add index.php to the list if you are using PHP index index.html index.nginx-debian.html readme.html; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. #try_files $uri $uri/ =404; try_files $uri $uri/ /index.php$is_args$args; } # include /etc/nginx/nginx-wp-common.conf; } nginx-wp-common.conf charset utf-8; location / { index index.php index.html readme.html; try_files $uri $uri/ /index.php?$args; } error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # Disallow .php files in uploads location ~* /(?:uploads|files)/.*\\.php$ { deny all; } # Add trailing slash to */wp-admin requests rewrite /wp-admin$ $scheme://$host$uri/ permanent; # Prevent hidden files (beginning with a period) from being served location ~ /\\. { access_log off; log_not_found off; deny all; } # Pass uploaded files to wp-includes/ms-files.php rewrite /files/$ /index.php last; if ($uri !~ wp-content/plugins) { rewrite /files/(.+)$ /wp-includes/ms-files.php?file=$1 last; } # Rewrite multisite in a subdirectory \u0026#39;.../wp-.*\u0026#39; and \u0026#39;.../*.php\u0026#39; if (!-e $request_filename) { rewrite ^/[_0-9a-zA-Z-]+(/wp-.*) $1 last; rewrite ^/[_0-9a-zA-Z-]+.*(/wp-admin/.*\\.php)$ $1 last; rewrite ^/[_0-9a-zA-Z-]+(/.*\\.php)$ $1 last; } location ~ \\.php$ { try_files $uri =404; include /etc/nginx/fastcgi_params; fastcgi_read_timeout 3600s; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass unix:/run/php/php7.0-fpm.sock; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_index index.php; } Tiếp tục cấu hình để tải và cài đặt wordpress.\nTạo một file main.yml trong roles/wordpress/handlers:\n--- - name: restart nginx service: name=nginx state=restarted become: yes - name: restart php5-fpm service: name=php5-fpm state=restarted Tiếp tục cấu hình để tải và cài đặt PHP.\nTạo một file main.yml trong roles/php/handlers:\n--- - name: restart nginx service: name=nginx state=restarted become: yes Tạo một file main.yml trong roles/php/tasks:\n--- # tasks file for php - name: Update apt cache apt: update_cache=yes cache_valid_time=3600 become: yes - name: Add ppa Repository become: yes apt_repository: repo=ppa:ondrej/php - name: Install php extensions apt: name: \u0026#34;{{ item }}\u0026#34; state: latest become: yes with_items: - php7.0 - php7.0-mysql - php7.0-gd - php7.0-mcrypt - name: Setup php-fpm replace: dest=/etc/php/7.0/cli/php.ini regexp=\u0026#34;(;cgi.fix_pathinfo=1)\u0026#34; replace=\u0026#34;cgi.fix_pathinfo=0\u0026#34; notify: - restart nginx become: yes - name: Add php settings template: src=../../nginx/templates/nginx-wp-common.conf dest=/etc/nginx/nginx-wp-common.conf owner=www-data group=www-data mode=0644 notify: - restart nginx become: yes - name: Remove apache2 become: true apt: name: apache2 state: absent "
},
{
	"uri": "//localhost:1313/vi/6-packer/",
	"title": "Viết Packer",
	"tags": [],
	"description": "",
	"content": "Đầu tiên chúng ta tạo cấu trúc thư mục Packer như dưới.\n$ tree ├── ansible │ ├── ansible-playbook-wordpress-nginx |......... ├── packer │ ├── scripts │ │ ├── ansible.sh │ ├── template.pkr.hcl Tạo moojti file ansible.sh trong scripts folder:\n#!/bin/bash -eux # Install Ansible repository. sudo apt-get update \u0026amp;\u0026amp; sudo apt-get upgrade -y sudo apt-get install -y software-properties-common sudo apt-add-repository -y ppa:ansible/ansible # Install Ansible. sudo apt-get update sudo apt-get install -y ansible Tạo một file template.pkr.hcl trong packer folder:\npacker { required_plugins { amazon = { version = \u0026#34;\u0026gt;= 1.2.8\u0026#34; source = \u0026#34;github.com/hashicorp/amazon\u0026#34; } } required_plugins { ansible = { version = \u0026#34;~\u0026gt; 1\u0026#34; source = \u0026#34;github.com/hashicorp/ansible\u0026#34; } } } source \u0026#34;amazon-ebs\u0026#34; \u0026#34;ubuntu\u0026#34; { ami_name = \u0026#34;your-ami-name\u0026#34; force_deregister = true instance_type = \u0026#34;t2.micro\u0026#34; region = \u0026#34;us-east-1\u0026#34; source_ami_filter { filters = { name = \u0026#34;ubuntu/images/*ubuntu-jammy-22.04-amd64-server-*\u0026#34;, root-device-type = \u0026#34;ebs\u0026#34; virtualization-type = \u0026#34;hvm\u0026#34; } most_recent = true owners = [\u0026#34;099720109477\u0026#34;] } ssh_username = \u0026#34;ubuntu\u0026#34; } build { name = \u0026#34;your-ami-name\u0026#34; sources = [\u0026#34;source.amazon-ebs.ubuntu\u0026#34;] provisioner \u0026#34;shell\u0026#34; { script = \u0026#34;scripts/ansible.sh\u0026#34; } provisioner \u0026#34;ansible-local\u0026#34; { group_vars = \u0026#34;../ansible/ansible-playbook-wordpress-nginx/group_vars\u0026#34; playbook_file = \u0026#34;../ansible/ansible-playbook-wordpress-nginx/playbook.yml\u0026#34; role_paths = [ \u0026#34;../ansible/ansible-playbook-wordpress-nginx/roles/nginx\u0026#34;, \u0026#34;../ansible/ansible-playbook-wordpress-nginx/roles/wordpress\u0026#34;, \u0026#34;../ansible/ansible-playbook-wordpress-nginx/roles/php\u0026#34; ] } } Sau khi code xong theo mẫu trên các bạn có thể chạy lệnh sau:\n## Check that a template is valid $ packer validate ## Install missing plugins or upgrade plugins $ packer init ## Build image(s) from template $ packer build template.pkr.hcl Trong khi chờ Packer build image, bạn có thể đi pha một tách cà phê trong khi chờ đợi.\nĐi tới Amazon Machine Images (AMIs), bạn sẽ nhìn thấy image của bạn đã được tạo.\n"
},
{
	"uri": "//localhost:1313/vi/7-terraform/",
	"title": "Viết Terraform",
	"tags": [],
	"description": "",
	"content": "Đầu tiên chúng ta tạo cấu trúc thư mục Terraform như dưới.\n$ tree . ├── modules │ └── services │ └── webserver-cluster │ ├── main.tf │ ├── outputs.tf │ └── variables.tf ├── prod │ ├── data-stores │ │ └── mysql │ │ ├── main.tf │ │ ├── outputs.tf │ │ └── variables.tf │ └── services │ └── webserver-cluster │ ├── main.tf │ ├── outputs.tf │ └── variables.tf Tạo một file main.tf trong /modules/services/webserver-cluster directory: terraform { required_version = \u0026#34;\u0026gt;= 1.0.0, \u0026lt; 2.0.0\u0026#34; required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 4.0\u0026#34; } } } provider \u0026#34;aws\u0026#34; { region = \u0026#34;us-east-1\u0026#34; } resource \u0026#34;aws_launch_configuration\u0026#34; \u0026#34;example\u0026#34; { image_id = var.ami instance_type = var.instance_type security_groups = [aws_security_group.instance.id] # Required when using a launch configuration with an auto scaling group. lifecycle { create_before_destroy = true } } resource \u0026#34;aws_autoscaling_group\u0026#34; \u0026#34;example\u0026#34; { launch_configuration = aws_launch_configuration.example.name vpc_zone_identifier = data.aws_subnets.default.ids target_group_arns = [aws_lb_target_group.asg.arn] health_check_type = \u0026#34;ELB\u0026#34; min_size = var.min_size max_size = var.max_size tag { key = \u0026#34;Name\u0026#34; value = var.cluster_name propagate_at_launch = true } } resource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;allow_server_http_inbound\u0026#34; { type = \u0026#34;ingress\u0026#34; security_group_id = aws_security_group.instance.id from_port = var.server_port to_port = var.server_port protocol = local.tcp_protocol cidr_blocks = local.all_ips } resource \u0026#34;aws_lb\u0026#34; \u0026#34;example\u0026#34; { name = var.cluster_name load_balancer_type = \u0026#34;application\u0026#34; subnets = data.aws_subnets.default.ids security_groups = [aws_security_group.alb.id] } resource \u0026#34;aws_lb_listener\u0026#34; \u0026#34;http\u0026#34; { load_balancer_arn = aws_lb.example.arn port = local.http_port protocol = \u0026#34;HTTP\u0026#34; # By default, return a simple 404 page default_action { type = \u0026#34;fixed-response\u0026#34; fixed_response { content_type = \u0026#34;text/plain\u0026#34; message_body = \u0026#34;404: page not found\u0026#34; status_code = 404 } } } resource \u0026#34;aws_lb_target_group\u0026#34; \u0026#34;asg\u0026#34; { name = var.cluster_name port = var.server_port protocol = \u0026#34;HTTP\u0026#34; vpc_id = data.aws_vpc.default.id health_check { path = \u0026#34;/\u0026#34; protocol = \u0026#34;HTTP\u0026#34; matcher = \u0026#34;200\u0026#34; interval = 15 timeout = 3 healthy_threshold = 2 unhealthy_threshold = 2 } } resource \u0026#34;aws_lb_listener_rule\u0026#34; \u0026#34;asg\u0026#34; { listener_arn = aws_lb_listener.http.arn priority = 100 condition { path_pattern { values = [\u0026#34;*\u0026#34;] } } action { type = \u0026#34;forward\u0026#34; target_group_arn = aws_lb_target_group.asg.arn } } resource \u0026#34;aws_security_group\u0026#34; \u0026#34;alb\u0026#34; { name = \u0026#34;${var.cluster_name}-alb\u0026#34; } resource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;allow_http_inbound\u0026#34; { type = \u0026#34;ingress\u0026#34; security_group_id = aws_security_group.alb.id from_port = local.http_port to_port = local.http_port protocol = local.tcp_protocol cidr_blocks = local.all_ips } resource \u0026#34;aws_security_group_rule\u0026#34; \u0026#34;allow_all_outbound\u0026#34; { type = \u0026#34;egress\u0026#34; security_group_id = aws_security_group.alb.id from_port = local.any_port to_port = local.any_port protocol = local.any_protocol cidr_blocks = local.all_ips } data \u0026#34;terraform_remote_state\u0026#34; \u0026#34;db\u0026#34; { backend = \u0026#34;s3\u0026#34; config = { bucket = var.db_remote_state_bucket key = var.db_remote_state_key region = \u0026#34;us-east-1\u0026#34; } } locals { http_port = 80 any_port = 0 any_protocol = \u0026#34;-1\u0026#34; tcp_protocol = \u0026#34;tcp\u0026#34; all_ips = [\u0026#34;0.0.0.0/0\u0026#34;] } data \u0026#34;aws_vpc\u0026#34; \u0026#34;default\u0026#34; { default = true } data \u0026#34;aws_subnets\u0026#34; \u0026#34;default\u0026#34; { filter { name = \u0026#34;vpc-id\u0026#34; values = [data.aws_vpc.default.id] } } Tạo một file variables.tf trong /modules/services/webserver-cluster directory: # --------------------------------------------------------------------------------------------------------------------- # REQUIRED PARAMETERS # You must provide a value for each of these parameters. # --------------------------------------------------------------------------------------------------------------------- variable \u0026#34;ami\u0026#34; { description = \u0026#34;ami\u0026#34; type = string default = \u0026#34;your ami created previous step\u0026#34; } variable \u0026#34;cluster_name\u0026#34; { description = \u0026#34;The name to use for all the cluster resources\u0026#34; type = string } variable \u0026#34;db_remote_state_bucket\u0026#34; { description = \u0026#34;The name of the S3 bucket for the database\u0026#39;s remote state\u0026#34; type = string } variable \u0026#34;db_remote_state_key\u0026#34; { description = \u0026#34;The path for the database\u0026#39;s remote state in S3\u0026#34; type = string } variable \u0026#34;instance_type\u0026#34; { description = \u0026#34;The type of EC2 Instances to run (e.g. t2.micro)\u0026#34; type = string } variable \u0026#34;min_size\u0026#34; { description = \u0026#34;The minimum number of EC2 Instances in the ASG\u0026#34; type = number } variable \u0026#34;max_size\u0026#34; { description = \u0026#34;The maximum number of EC2 Instances in the ASG\u0026#34; type = number } variable \u0026#34;server_port\u0026#34; { description = \u0026#34;The port the server will use for HTTP requests\u0026#34; type = number default = 80 } Tạo một file outputs.tf trong /modules/services/webserver-cluster directory: output \u0026#34;alb_dns_name\u0026#34; { value = aws_lb.example.dns_name description = \u0026#34;The domain name of the load balancer\u0026#34; } output \u0026#34;asg_name\u0026#34; { value = aws_autoscaling_group.example.name description = \u0026#34;The name of the Auto Scaling Group\u0026#34; } output \u0026#34;alb_security_group_id\u0026#34; { value = aws_security_group.alb.id description = \u0026#34;The ID of the Security Group attached to the load balancer\u0026#34; } Tạo một file main.tf trong /prod/services/webserver-cluster directory terraform { required_version = \u0026#34;\u0026gt;= 1.0.0, \u0026lt; 2.0.0\u0026#34; required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 4.0\u0026#34; } } } provider \u0026#34;aws\u0026#34; { region = \u0026#34;us-east-1\u0026#34; } module \u0026#34;webserver_cluster\u0026#34; { source = \u0026#34;../../../modules/services/webserver-cluster\u0026#34; cluster_name = var.cluster_name db_remote_state_bucket = var.db_remote_state_bucket db_remote_state_key = var.db_remote_state_key instance_type = \u0026#34;t2.micro\u0026#34; min_size = 2 max_size = 10 } resource \u0026#34;aws_autoscaling_schedule\u0026#34; \u0026#34;scale_out_during_business_hours\u0026#34; { scheduled_action_name = \u0026#34;scale-out-during-business-hours\u0026#34; min_size = 2 max_size = 10 desired_capacity = 10 recurrence = \u0026#34;0 9 * * *\u0026#34; autoscaling_group_name = module.webserver_cluster.asg_name } resource \u0026#34;aws_autoscaling_schedule\u0026#34; \u0026#34;scale_in_at_night\u0026#34; { scheduled_action_name = \u0026#34;scale-in-at-night\u0026#34; min_size = 2 max_size = 10 desired_capacity = 2 recurrence = \u0026#34;0 17 * * *\u0026#34; autoscaling_group_name = module.webserver_cluster.asg_name } Tạo một file variables.tf trong /prod/services/webserver-cluster directory # --------------------------------------------------------------------------------------------------------------------- # REQUIRED PARAMETERS # You must provide a value for each of these parameters. # --------------------------------------------------------------------------------------------------------------------- variable \u0026#34;db_remote_state_bucket\u0026#34; { description = \u0026#34;The name of the S3 bucket used for the database\u0026#39;s remote state storage\u0026#34; type = string } variable \u0026#34;db_remote_state_key\u0026#34; { description = \u0026#34;The name of the key in the S3 bucket used for the database\u0026#39;s remote state storage\u0026#34; type = string } # --------------------------------------------------------------------------------------------------------------------- # OPTIONAL PARAMETERS # These parameters have reasonable defaults. # --------------------------------------------------------------------------------------------------------------------- variable \u0026#34;cluster_name\u0026#34; { description = \u0026#34;The name to use to namespace all the resources in the cluster\u0026#34; type = string default = \u0026#34;webservers-prod\u0026#34; } Tạo một file outputs.tf trong /prod/services/webserver-cluster directory output \u0026#34;alb_dns_name\u0026#34; { value = module.webserver_cluster.alb_dns_name description = \u0026#34;The domain name of the load balancer\u0026#34; } Tạo một file main.tf trong /prod/data-stores/mysql directory terraform { required_version = \u0026#34;\u0026gt;= 1.0.0, \u0026lt; 2.0.0\u0026#34; required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 4.0\u0026#34; } } backend \u0026#34;s3\u0026#34; { # This backend configuration is filled in automatically at test time by Terratest. If you wish to run this example # manually, uncomment and fill in the config below. # bucket = \u0026#34;\u0026lt;YOUR S3 BUCKET\u0026gt;\u0026#34; # key = \u0026#34;\u0026lt;SOME PATH\u0026gt;/terraform.tfstate\u0026#34; # region = \u0026#34;us-east-1\u0026#34; # dynamodb_table = \u0026#34;\u0026lt;YOUR DYNAMODB TABLE\u0026gt;\u0026#34; # encrypt = true } } provider \u0026#34;aws\u0026#34; { region = \u0026#34;us-east-1\u0026#34; } resource \u0026#34;aws_db_instance\u0026#34; \u0026#34;example\u0026#34; { identifier_prefix = \u0026#34;terraform-up-and-running\u0026#34; engine = \u0026#34;mysql\u0026#34; allocated_storage = 10 instance_class = \u0026#34;db.t2.micro\u0026#34; db_name = var.db_name username = var.db_username password = var.db_password skip_final_snapshot = true } Tạo một file main.tf trong /prod/data-stores/mysql directory # --------------------------------------------------------------------------------------------------------------------- # REQUIRED PARAMETERS # You must provide a value for each of these parameters. # --------------------------------------------------------------------------------------------------------------------- variable \u0026#34;db_username\u0026#34; { description = \u0026#34;The username for the database\u0026#34; type = string sensitive = true } variable \u0026#34;db_password\u0026#34; { description = \u0026#34;The password for the database\u0026#34; type = string sensitive = true } # --------------------------------------------------------------------------------------------------------------------- # OPTIONAL PARAMETERS # These parameters have reasonable defaults. # --------------------------------------------------------------------------------------------------------------------- variable \u0026#34;db_name\u0026#34; { description = \u0026#34;The name to use for the database\u0026#34; type = string default = \u0026#34;example_database_prod\u0026#34; } Tạo một file main.tf trong /prod/data-stores/mysql directory output \u0026#34;address\u0026#34; { value = aws_db_instance.example.address description = \u0026#34;Connect to the database at this endpoint\u0026#34; } output \u0026#34;port\u0026#34; { value = aws_db_instance.example.port description = \u0026#34;The port the database is listening on\u0026#34; } Sau khi viết mã terraform, bạn có thể chạy terraform fmt để định dạng lại cấu hình của mình.\n## Reformat your configuration in the standard style $ terraform fmt ## Prepare your working directory for other commands $ terraform init Bạn cần phải chạy terraform init để khởi tạo.\nChạy terraform apply để tạo infrastructure của bạn.\n## Create or update infrastructure $ terraform apply Nhập \u0026ldquo;yes\u0026rdquo;.\nĐây là kết quả sau khi Terraform chạy xong. Bạn có thể check thêm trên console.\nEC2 Instance Auto Scaling Group Load Balancers Target Groups Check your website "
},
{
	"uri": "//localhost:1313/vi/8-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ tiến hành các bước sau để xóa các tài nguyên chúng ta đã tạo trong bài thực hành này.\n## Destroy previously-created infrastructure terraform destroy Nhập \u0026ldquo;Yes\u0026rdquo;.\nCheck EC2 Instance Đi tới EC2 service management console Check Auto Scaling Group Check Load Balancers Check Target Groups "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]